(masclet-imperi) PS C:\Proyectos\claude\masclet-imperi-web> pytest backend\tests\unit\models\test_animal.py -v
=============================================== test session starts ===============================================
platform win32 -- Python 3.11.11, pytest-8.3.4, pluggy-1.5.0 -- C:\Users\Usuario\anaconda3\envs\masclet-imperi\python.exe
cachedir: .pytest_cache
rootdir: C:\Proyectos\claude\masclet-imperi-web\backend
configfile: pyproject.toml
plugins: anyio-3.7.1, asyncio-0.25.3
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=function
collected 5 items

backend\tests\unit\models\test_animal.py::test_create_animal_basic ERROR                                     [ 20%]
backend\tests\unit\models\test_animal.py::test_create_animal_complete ERROR                                  [ 40%]
backend\tests\unit\models\test_animal.py::test_animal_parto_relationship ERROR                               [ 60%]
backend\tests\unit\models\test_animal.py::test_create_animal_with_optional_fields ERROR                      [ 80%]
backend\tests\unit\models\test_animal.py::test_validate_constraints ERROR                                    [100%]

===================================================== ERRORS ======================================================
___________________________________ ERROR at setup of test_create_animal_basic ____________________________________

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671664AB0>

    def finish_recv(trans, key, ov):
        try:
>           return ov.getresult()
E           OSError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:494: OSError

During handling of the above exception, another exception occurred:

self = <_ProactorSocketTransport closed>
fut = <_OverlappedFuture finished exception=ConnectionResetError(22, 'El nombre de red especificado ya no está disponible', None, 64, None)>

    def _loop_reading(self, fut=None):
        length = -1
        data = None
        try:
            if fut is not None:
                assert self._read_fut is fut or (self._read_fut is None and
                                                 self._closing)
                self._read_fut = None
                if fut.done():
                    # deliver data later in "finally" clause
>                   length = fut.result()

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\proactor_events.py:286:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:854: in _poll
    value = callback(transferred, key, ov)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671664AB0>

    def finish_recv(trans, key, ov):
        try:
            return ov.getresult()
        except OSError as exc:
            if exc.winerror in (_overlapped.ERROR_NETNAME_DELETED,
                                _overlapped.ERROR_OPERATION_ABORTED):
>               raise ConnectionResetError(*exc.args)
E               ConnectionResetError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:498: ConnectionResetError

The above exception was the direct cause of the following exception:

request = <SubRequest 'test_db' for <Coroutine test_create_animal_basic>>, kwargs = {}
func = <function test_db at 0x000002366FEDFA60>, event_loop_fixture_id = 'event_loop'
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x00000236710C7E20>
setup_task = <Task finished name='Task-1' coro=<_wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup() done, de...ytest_asyncio\plugin.py:323> exception=ConnectionDoesNotExistError('connection was closed in the middle of operation')>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: FixtureRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(fixture, request.instance)
        event_loop_fixture_id = _get_event_loop_fixture_id_for_async_fixture(
            request, func
        )
        event_loop = request.getfixturevalue(event_loop_fixture_id)
        kwargs.pop(event_loop_fixture_id, None)
        gen_obj = func(**_add_kwargs(func, kwargs, event_loop, request))

        async def setup():
            res = await gen_obj.__anext__()  # type: ignore[union-attr]
            return res

        context = contextvars.copy_context()
        setup_task = _create_task_in_context(event_loop, setup(), context)
>       result = event_loop.run_until_complete(setup_task)

c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:329:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\base_events.py:654: in run_until_complete
    return future.result()
c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:324: in setup
    res = await gen_obj.__anext__()  # type: ignore[union-attr]
backend\tests\conftest.py:37: in test_db
    await Tortoise.generate_schemas()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\__init__.py:594: in generate_schemas
    await generate_schema_for_client(connection, safe)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\utils.py:44: in generate_schema_for_client
    await generator.generate_from_string(schema)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\schema_generator.py:504: in generate_from_string
    await self.client.execute_script(creation_string)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:31: in _translate_exceptions
    return await self._translate_exceptions(func, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:87: in _translate_exceptions
    return await func(self, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:150: in execute_script
    async with self.acquire_connection() as connection:
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:360: in __aenter__
    await self.ensure_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:357: in ensure_connection
    await self.client.create_connection(with_db=True)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:59: in create_connection
    self._pool = await self.create_pool(password=self.password, **self._template)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:70: in create_pool
    return await asyncpg.create_pool(None, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:418: in _async__init__
    await self._initialize()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:445: in _initialize
    await first_ch.connect()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:132: in connect
    self._con = await self._pool._get_new_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:517: in _get_new_connection
    con = await self._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

params = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')
retry = True, addr = ('localhost', 5432), loop = <ProactorEventLoop running=False closed=False debug=False>
config = ConnectionConfiguration(command_timeout=None, statement_cache_size=100, max_cached_statement_lifetime=300, max_cacheable_statement_size=15360)
connection_class = <class 'asyncpg.connection.Connection'>, record_class = <class 'asyncpg.Record'>
params_input = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')

    async def __connect_addr(
        params,
        retry,
        addr,
        loop,
        config,
        connection_class,
        record_class,
        params_input,
    ):
        connected = _create_future(loop)

        proto_factory = lambda: protocol.Protocol(
            addr, connected, params, record_class, loop)

        if isinstance(addr, str):
            # UNIX socket
            connector = loop.create_unix_connection(proto_factory, addr)

        elif params.ssl and params.ssl_negotiation is SSLNegotiation.direct:
            # if ssl and ssl_negotiation is `direct`, skip STARTTLS and perform
            # direct SSL connection
            connector = loop.create_connection(
                proto_factory, *addr, ssl=params.ssl
            )

        elif params.ssl:
            connector = _create_ssl_connection(
                proto_factory, *addr, loop=loop, ssl_context=params.ssl,
                ssl_is_advisory=params.sslmode == SSLMode.prefer)
        else:
            connector = loop.create_connection(proto_factory, *addr)

        tr, pr = await connector

        try:
>           await connected
E           asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:934: ConnectionDoesNotExistError
__________________________________ ERROR at setup of test_create_animal_complete __________________________________

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671A54570>

    def finish_recv(trans, key, ov):
        try:
>           return ov.getresult()
E           OSError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:494: OSError

During handling of the above exception, another exception occurred:

self = <_ProactorSocketTransport closed>
fut = <_OverlappedFuture finished exception=ConnectionResetError(22, 'El nombre de red especificado ya no está disponible', None, 64, None)>

    def _loop_reading(self, fut=None):
        length = -1
        data = None
        try:
            if fut is not None:
                assert self._read_fut is fut or (self._read_fut is None and
                                                 self._closing)
                self._read_fut = None
                if fut.done():
                    # deliver data later in "finally" clause
>                   length = fut.result()

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\proactor_events.py:286:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:854: in _poll
    value = callback(transferred, key, ov)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671A54570>

    def finish_recv(trans, key, ov):
        try:
            return ov.getresult()
        except OSError as exc:
            if exc.winerror in (_overlapped.ERROR_NETNAME_DELETED,
                                _overlapped.ERROR_OPERATION_ABORTED):
>               raise ConnectionResetError(*exc.args)
E               ConnectionResetError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:498: ConnectionResetError

The above exception was the direct cause of the following exception:

request = <SubRequest 'test_db' for <Coroutine test_create_animal_complete>>, kwargs = {}
func = <function test_db at 0x000002366FEDFA60>, event_loop_fixture_id = 'event_loop'
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x00000236716B8180>
setup_task = <Task finished name='Task-2' coro=<_wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup() done, de...ytest_asyncio\plugin.py:323> exception=ConnectionDoesNotExistError('connection was closed in the middle of operation')>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: FixtureRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(fixture, request.instance)
        event_loop_fixture_id = _get_event_loop_fixture_id_for_async_fixture(
            request, func
        )
        event_loop = request.getfixturevalue(event_loop_fixture_id)
        kwargs.pop(event_loop_fixture_id, None)
        gen_obj = func(**_add_kwargs(func, kwargs, event_loop, request))

        async def setup():
            res = await gen_obj.__anext__()  # type: ignore[union-attr]
            return res

        context = contextvars.copy_context()
        setup_task = _create_task_in_context(event_loop, setup(), context)
>       result = event_loop.run_until_complete(setup_task)

c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:329:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\base_events.py:654: in run_until_complete
    return future.result()
c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:324: in setup
    res = await gen_obj.__anext__()  # type: ignore[union-attr]
backend\tests\conftest.py:37: in test_db
    await Tortoise.generate_schemas()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\__init__.py:594: in generate_schemas
    await generate_schema_for_client(connection, safe)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\utils.py:44: in generate_schema_for_client
    await generator.generate_from_string(schema)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\schema_generator.py:504: in generate_from_string
    await self.client.execute_script(creation_string)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:31: in _translate_exceptions
    return await self._translate_exceptions(func, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:87: in _translate_exceptions
    return await func(self, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:150: in execute_script
    async with self.acquire_connection() as connection:
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:360: in __aenter__
    await self.ensure_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:357: in ensure_connection
    await self.client.create_connection(with_db=True)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:59: in create_connection
    self._pool = await self.create_pool(password=self.password, **self._template)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:70: in create_pool
    return await asyncpg.create_pool(None, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:418: in _async__init__
    await self._initialize()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:445: in _initialize
    await first_ch.connect()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:132: in connect
    self._con = await self._pool._get_new_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:517: in _get_new_connection
    con = await self._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

params = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')
retry = True, addr = ('localhost', 5432), loop = <ProactorEventLoop running=False closed=False debug=False>
config = ConnectionConfiguration(command_timeout=None, statement_cache_size=100, max_cached_statement_lifetime=300, max_cacheable_statement_size=15360)
connection_class = <class 'asyncpg.connection.Connection'>, record_class = <class 'asyncpg.Record'>
params_input = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')

    async def __connect_addr(
        params,
        retry,
        addr,
        loop,
        config,
        connection_class,
        record_class,
        params_input,
    ):
        connected = _create_future(loop)

        proto_factory = lambda: protocol.Protocol(
            addr, connected, params, record_class, loop)

        if isinstance(addr, str):
            # UNIX socket
            connector = loop.create_unix_connection(proto_factory, addr)

        elif params.ssl and params.ssl_negotiation is SSLNegotiation.direct:
            # if ssl and ssl_negotiation is `direct`, skip STARTTLS and perform
            # direct SSL connection
            connector = loop.create_connection(
                proto_factory, *addr, ssl=params.ssl
            )

        elif params.ssl:
            connector = _create_ssl_connection(
                proto_factory, *addr, loop=loop, ssl_context=params.ssl,
                ssl_is_advisory=params.sslmode == SSLMode.prefer)
        else:
            connector = loop.create_connection(proto_factory, *addr)

        tr, pr = await connector

        try:
>           await connected
E           asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:934: ConnectionDoesNotExistError
________________________________ ERROR at setup of test_animal_parto_relationship _________________________________

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671664F30>

    def finish_recv(trans, key, ov):
        try:
>           return ov.getresult()
E           OSError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:494: OSError

During handling of the above exception, another exception occurred:

self = <_ProactorSocketTransport closed>
fut = <_OverlappedFuture finished exception=ConnectionResetError(22, 'El nombre de red especificado ya no está disponible', None, 64, None)>

    def _loop_reading(self, fut=None):
        length = -1
        data = None
        try:
            if fut is not None:
                assert self._read_fut is fut or (self._read_fut is None and
                                                 self._closing)
                self._read_fut = None
                if fut.done():
                    # deliver data later in "finally" clause
>                   length = fut.result()

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\proactor_events.py:286:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:854: in _poll
    value = callback(transferred, key, ov)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671664F30>

    def finish_recv(trans, key, ov):
        try:
            return ov.getresult()
        except OSError as exc:
            if exc.winerror in (_overlapped.ERROR_NETNAME_DELETED,
                                _overlapped.ERROR_OPERATION_ABORTED):
>               raise ConnectionResetError(*exc.args)
E               ConnectionResetError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:498: ConnectionResetError

The above exception was the direct cause of the following exception:

request = <SubRequest 'test_db' for <Coroutine test_animal_parto_relationship>>, kwargs = {}
func = <function test_db at 0x000002366FEDFA60>, event_loop_fixture_id = 'event_loop'
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x000002366FFE2C00>
setup_task = <Task finished name='Task-4' coro=<_wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup() done, de...ytest_asyncio\plugin.py:323> exception=ConnectionDoesNotExistError('connection was closed in the middle of operation')>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: FixtureRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(fixture, request.instance)
        event_loop_fixture_id = _get_event_loop_fixture_id_for_async_fixture(
            request, func
        )
        event_loop = request.getfixturevalue(event_loop_fixture_id)
        kwargs.pop(event_loop_fixture_id, None)
        gen_obj = func(**_add_kwargs(func, kwargs, event_loop, request))

        async def setup():
            res = await gen_obj.__anext__()  # type: ignore[union-attr]
            return res

        context = contextvars.copy_context()
        setup_task = _create_task_in_context(event_loop, setup(), context)
>       result = event_loop.run_until_complete(setup_task)

c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:329:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\base_events.py:654: in run_until_complete
    return future.result()
c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:324: in setup
    res = await gen_obj.__anext__()  # type: ignore[union-attr]
backend\tests\conftest.py:37: in test_db
    await Tortoise.generate_schemas()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\__init__.py:594: in generate_schemas
    await generate_schema_for_client(connection, safe)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\utils.py:44: in generate_schema_for_client
    await generator.generate_from_string(schema)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\schema_generator.py:504: in generate_from_string
    await self.client.execute_script(creation_string)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:31: in _translate_exceptions
    return await self._translate_exceptions(func, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:87: in _translate_exceptions
    return await func(self, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:150: in execute_script
    async with self.acquire_connection() as connection:
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:360: in __aenter__
    await self.ensure_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:357: in ensure_connection
    await self.client.create_connection(with_db=True)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:59: in create_connection
    self._pool = await self.create_pool(password=self.password, **self._template)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:70: in create_pool
    return await asyncpg.create_pool(None, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:418: in _async__init__
    await self._initialize()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:445: in _initialize
    await first_ch.connect()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:132: in connect
    self._con = await self._pool._get_new_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:517: in _get_new_connection
    con = await self._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

params = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')
retry = True, addr = ('localhost', 5432), loop = <ProactorEventLoop running=False closed=False debug=False>
config = ConnectionConfiguration(command_timeout=None, statement_cache_size=100, max_cached_statement_lifetime=300, max_cacheable_statement_size=15360)
connection_class = <class 'asyncpg.connection.Connection'>, record_class = <class 'asyncpg.Record'>
params_input = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')

    async def __connect_addr(
        params,
        retry,
        addr,
        loop,
        config,
        connection_class,
        record_class,
        params_input,
    ):
        connected = _create_future(loop)

        proto_factory = lambda: protocol.Protocol(
            addr, connected, params, record_class, loop)

        if isinstance(addr, str):
            # UNIX socket
            connector = loop.create_unix_connection(proto_factory, addr)

        elif params.ssl and params.ssl_negotiation is SSLNegotiation.direct:
            # if ssl and ssl_negotiation is `direct`, skip STARTTLS and perform
            # direct SSL connection
            connector = loop.create_connection(
                proto_factory, *addr, ssl=params.ssl
            )

        elif params.ssl:
            connector = _create_ssl_connection(
                proto_factory, *addr, loop=loop, ssl_context=params.ssl,
                ssl_is_advisory=params.sslmode == SSLMode.prefer)
        else:
            connector = loop.create_connection(proto_factory, *addr)

        tr, pr = await connector

        try:
>           await connected
E           asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:934: ConnectionDoesNotExistError
____________________________ ERROR at setup of test_create_animal_with_optional_fields ____________________________

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671A56730>

    def finish_recv(trans, key, ov):
        try:
>           return ov.getresult()
E           OSError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:494: OSError

During handling of the above exception, another exception occurred:

self = <_ProactorSocketTransport closed>
fut = <_OverlappedFuture finished exception=ConnectionResetError(22, 'El nombre de red especificado ya no está disponible', None, 64, None)>

    def _loop_reading(self, fut=None):
        length = -1
        data = None
        try:
            if fut is not None:
                assert self._read_fut is fut or (self._read_fut is None and
                                                 self._closing)
                self._read_fut = None
                if fut.done():
                    # deliver data later in "finally" clause
>                   length = fut.result()

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\proactor_events.py:286:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:854: in _poll
    value = callback(transferred, key, ov)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671A56730>

    def finish_recv(trans, key, ov):
        try:
            return ov.getresult()
        except OSError as exc:
            if exc.winerror in (_overlapped.ERROR_NETNAME_DELETED,
                                _overlapped.ERROR_OPERATION_ABORTED):
>               raise ConnectionResetError(*exc.args)
E               ConnectionResetError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:498: ConnectionResetError

The above exception was the direct cause of the following exception:

request = <SubRequest 'test_db' for <Coroutine test_create_animal_with_optional_fields>>, kwargs = {}
func = <function test_db at 0x000002366FEDFA60>, event_loop_fixture_id = 'event_loop'
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x00000236710C7F60>
setup_task = <Task finished name='Task-6' coro=<_wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup() done, de...ytest_asyncio\plugin.py:323> exception=ConnectionDoesNotExistError('connection was closed in the middle of operation')>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: FixtureRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(fixture, request.instance)
        event_loop_fixture_id = _get_event_loop_fixture_id_for_async_fixture(
            request, func
        )
        event_loop = request.getfixturevalue(event_loop_fixture_id)
        kwargs.pop(event_loop_fixture_id, None)
        gen_obj = func(**_add_kwargs(func, kwargs, event_loop, request))

        async def setup():
            res = await gen_obj.__anext__()  # type: ignore[union-attr]
            return res

        context = contextvars.copy_context()
        setup_task = _create_task_in_context(event_loop, setup(), context)
>       result = event_loop.run_until_complete(setup_task)

c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:329:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\base_events.py:654: in run_until_complete
    return future.result()
c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:324: in setup
    res = await gen_obj.__anext__()  # type: ignore[union-attr]
backend\tests\conftest.py:37: in test_db
    await Tortoise.generate_schemas()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\__init__.py:594: in generate_schemas
    await generate_schema_for_client(connection, safe)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\utils.py:44: in generate_schema_for_client
    await generator.generate_from_string(schema)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\schema_generator.py:504: in generate_from_string
    await self.client.execute_script(creation_string)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:31: in _translate_exceptions
    return await self._translate_exceptions(func, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:87: in _translate_exceptions
    return await func(self, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:150: in execute_script
    async with self.acquire_connection() as connection:
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:360: in __aenter__
    await self.ensure_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:357: in ensure_connection
    await self.client.create_connection(with_db=True)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:59: in create_connection
    self._pool = await self.create_pool(password=self.password, **self._template)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:70: in create_pool
    return await asyncpg.create_pool(None, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:418: in _async__init__
    await self._initialize()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:445: in _initialize
    await first_ch.connect()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:132: in connect
    self._con = await self._pool._get_new_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:517: in _get_new_connection
    con = await self._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

params = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')
retry = True, addr = ('localhost', 5432), loop = <ProactorEventLoop running=False closed=False debug=False>
config = ConnectionConfiguration(command_timeout=None, statement_cache_size=100, max_cached_statement_lifetime=300, max_cacheable_statement_size=15360)
connection_class = <class 'asyncpg.connection.Connection'>, record_class = <class 'asyncpg.Record'>
params_input = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')

    async def __connect_addr(
        params,
        retry,
        addr,
        loop,
        config,
        connection_class,
        record_class,
        params_input,
    ):
        connected = _create_future(loop)

        proto_factory = lambda: protocol.Protocol(
            addr, connected, params, record_class, loop)

        if isinstance(addr, str):
            # UNIX socket
            connector = loop.create_unix_connection(proto_factory, addr)

        elif params.ssl and params.ssl_negotiation is SSLNegotiation.direct:
            # if ssl and ssl_negotiation is `direct`, skip STARTTLS and perform
            # direct SSL connection
            connector = loop.create_connection(
                proto_factory, *addr, ssl=params.ssl
            )

        elif params.ssl:
            connector = _create_ssl_connection(
                proto_factory, *addr, loop=loop, ssl_context=params.ssl,
                ssl_is_advisory=params.sslmode == SSLMode.prefer)
        else:
            connector = loop.create_connection(proto_factory, *addr)

        tr, pr = await connector

        try:
>           await connected
E           asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:934: ConnectionDoesNotExistError
___________________________________ ERROR at setup of test_validate_constraints ___________________________________

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671A57030>

    def finish_recv(trans, key, ov):
        try:
>           return ov.getresult()
E           OSError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:494: OSError

During handling of the above exception, another exception occurred:

self = <_ProactorSocketTransport closed>
fut = <_OverlappedFuture finished exception=ConnectionResetError(22, 'El nombre de red especificado ya no está disponible', None, 64, None)>

    def _loop_reading(self, fut=None):
        length = -1
        data = None
        try:
            if fut is not None:
                assert self._read_fut is fut or (self._read_fut is None and
                                                 self._closing)
                self._read_fut = None
                if fut.done():
                    # deliver data later in "finally" clause
>                   length = fut.result()

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\proactor_events.py:286:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:854: in _poll
    value = callback(transferred, key, ov)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

trans = 0, key = 0, ov = <_overlapped.Overlapped object at 0x0000023671A57030>

    def finish_recv(trans, key, ov):
        try:
            return ov.getresult()
        except OSError as exc:
            if exc.winerror in (_overlapped.ERROR_NETNAME_DELETED,
                                _overlapped.ERROR_OPERATION_ABORTED):
>               raise ConnectionResetError(*exc.args)
E               ConnectionResetError: [WinError 64] El nombre de red especificado ya no está disponible

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\windows_events.py:498: ConnectionResetError

The above exception was the direct cause of the following exception:

request = <SubRequest 'test_db' for <Coroutine test_validate_constraints>>, kwargs = {}
func = <function test_db at 0x000002366FEDFA60>, event_loop_fixture_id = 'event_loop'
setup = <function _wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup at 0x00000236716FFB00>
setup_task = <Task finished name='Task-8' coro=<_wrap_asyncgen_fixture.<locals>._asyncgen_fixture_wrapper.<locals>.setup() done, de...ytest_asyncio\plugin.py:323> exception=ConnectionDoesNotExistError('connection was closed in the middle of operation')>

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: FixtureRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(fixture, request.instance)
        event_loop_fixture_id = _get_event_loop_fixture_id_for_async_fixture(
            request, func
        )
        event_loop = request.getfixturevalue(event_loop_fixture_id)
        kwargs.pop(event_loop_fixture_id, None)
        gen_obj = func(**_add_kwargs(func, kwargs, event_loop, request))

        async def setup():
            res = await gen_obj.__anext__()  # type: ignore[union-attr]
            return res

        context = contextvars.copy_context()
        setup_task = _create_task_in_context(event_loop, setup(), context)
>       result = event_loop.run_until_complete(setup_task)

c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:329:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\asyncio\base_events.py:654: in run_until_complete
    return future.result()
c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:324: in setup
    res = await gen_obj.__anext__()  # type: ignore[union-attr]
backend\tests\conftest.py:37: in test_db
    await Tortoise.generate_schemas()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\__init__.py:594: in generate_schemas
    await generate_schema_for_client(connection, safe)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\utils.py:44: in generate_schema_for_client
    await generator.generate_from_string(schema)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\schema_generator.py:504: in generate_from_string
    await self.client.execute_script(creation_string)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:31: in _translate_exceptions
    return await self._translate_exceptions(func, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:87: in _translate_exceptions
    return await func(self, *args, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base_postgres\client.py:150: in execute_script
    async with self.acquire_connection() as connection:
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:360: in __aenter__
    await self.ensure_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\base\client.py:357: in ensure_connection
    await self.client.create_connection(with_db=True)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:59: in create_connection
    self._pool = await self.create_pool(password=self.password, **self._template)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\tortoise\backends\asyncpg\client.py:70: in create_pool
    return await asyncpg.create_pool(None, **kwargs)
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:418: in _async__init__
    await self._initialize()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:445: in _initialize
    await first_ch.connect()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:132: in connect
    self._con = await self._pool._get_new_connection()
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\pool.py:517: in _get_new_connection
    con = await self._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

params = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')
retry = True, addr = ('localhost', 5432), loop = <ProactorEventLoop running=False closed=False debug=False>
config = ConnectionConfiguration(command_timeout=None, statement_cache_size=100, max_cached_statement_lifetime=300, max_cacheable_statement_size=15360)
connection_class = <class 'asyncpg.connection.Connection'>, record_class = <class 'asyncpg.Record'>
params_input = ConnectionParameters(user='masclet_user', password='masclet_pass', database='masclet_imperi_test', ssl=<ssl.SSLContext...s: 'postgres'>, server_settings={}, target_session_attrs=<SessionAttribute.any: 'any'>, krbsrvname=None, gsslib='sspi')

    async def __connect_addr(
        params,
        retry,
        addr,
        loop,
        config,
        connection_class,
        record_class,
        params_input,
    ):
        connected = _create_future(loop)

        proto_factory = lambda: protocol.Protocol(
            addr, connected, params, record_class, loop)

        if isinstance(addr, str):
            # UNIX socket
            connector = loop.create_unix_connection(proto_factory, addr)

        elif params.ssl and params.ssl_negotiation is SSLNegotiation.direct:
            # if ssl and ssl_negotiation is `direct`, skip STARTTLS and perform
            # direct SSL connection
            connector = loop.create_connection(
                proto_factory, *addr, ssl=params.ssl
            )

        elif params.ssl:
            connector = _create_ssl_connection(
                proto_factory, *addr, loop=loop, ssl_context=params.ssl,
                ssl_is_advisory=params.sslmode == SSLMode.prefer)
        else:
            connector = loop.create_connection(proto_factory, *addr)

        tr, pr = await connector

        try:
>           await connected
E           asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation

C:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\asyncpg\connect_utils.py:934: ConnectionDoesNotExistError
================================================ warnings summary =================================================
..\..\..\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:256
  c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:256: PytestDeprecationWarning: test_db is asynchronous and explicitly requests the "event_loop" fixture. Asynchronous fixtures and test functions should use "asyncio.get_running_loop()" instead.
    warnings.warn(

tests/unit/models/test_animal.py::test_create_animal_basic
tests/unit/models/test_animal.py::test_create_animal_complete
tests/unit/models/test_animal.py::test_animal_parto_relationship
tests/unit/models/test_animal.py::test_create_animal_with_optional_fields
tests/unit/models/test_animal.py::test_validate_constraints
  c:\Users\Usuario\anaconda3\envs\masclet-imperi\Lib\site-packages\pytest_asyncio\plugin.py:867: DeprecationWarning: The event_loop fixture provided by pytest-asyncio has been redefined in
  C:\Proyectos\claude\masclet-imperi-web\backend\tests\conftest.py:11
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "loop_scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_policy
  fixture.

    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============================================= short test summary info =============================================
ERROR backend\tests\unit\models\test_animal.py::test_create_animal_basic - asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation
ERROR backend\tests\unit\models\test_animal.py::test_create_animal_complete - asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation
ERROR backend\tests\unit\models\test_animal.py::test_animal_parto_relationship - asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation
ERROR backend\tests\unit\models\test_animal.py::test_create_animal_with_optional_fields - asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation
ERROR backend\tests\unit\models\test_animal.py::test_validate_constraints - asyncpg.exceptions.ConnectionDoesNotExistError: connection was closed in the middle of operation
========================================== 6 warnings, 5 errors in 1.14s ==========================================
(masclet-imperi) PS C:\Proyectos\claude\masclet-imperi-web>